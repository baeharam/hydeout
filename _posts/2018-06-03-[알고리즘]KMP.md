---
layout: post
category: Algorithm
---

# KMP algorithm

KMP 알고리즘은 시간복잡도가 무려 $\theta(n+m)$으로 문자열 매칭 알고리즘 중에서 굉장히 빠른 편에 속한다. 이전에 정리했던 라빈-카프 알고리즘보다는 당연히 더 빠르고 불필요한 비교를 훨씬 줄인다는 장점이 있다. 그러나 뭔가 엄밀하게 이해하기가 힘들고 다른 사람들 블로그를 봐도 이해하기가 어려워서 Introductions to algorihtm 책으로 정리하고자 한다.

## 원리

![default](https://user-images.githubusercontent.com/35518072/40884406-f2b2cf14-674d-11e8-8a69-9bf553ce97f6.JPG)

위 그림을 보면 T가 텍스트이고 P가 패턴이다. T에서 P가 언제 등장하고 몇 번 등장하는지 알아내기 위한 알고리즘이 바로 문자열 매칭 알고리즘이다. (a)를 보면 패턴의 5번째까지 문자는 일치하지만 6번째에 불일치가 일어난다. 여기서 shift를 1번해서 처음부터 검사하는 것이 기존의 알고리즘이라면, KMP는 패턴 안에서 반복되는 문자열을 파악하여 그곳으로 shift를 한다. (b)를 보면 2만큼 shift를 거쳐 다시 a가 나오는 인덱스부터 비교를 한다는 것을 알 수 있다. 

왜 2번 움직일까? ababaca에서 반복되는 문자열을 찾으면 aba라는 것을 쉽게 알 수 있다. 문자열에서 ababaca가 반복되는 것을 관찰해야 하는 것이 목적이기 때문에 텍스트에서 매칭이 실패한다면 다시 매칭 성공 가능성이 있는 것은 반복되는 문자부터인 것이 자명하다. 따라서 위 그림의 경우 ababa가 매칭되었기 때문에 다시 aba가 나타나는 곳으로 가서 비교를 하는 것이다.

이걸 좀더 형식적으로 쓴다면 다음과 같이 쓸 수 있다.

**"패턴 $P[1...q]$ 가 텍스트 $T[s+1...s+q]$ 와 매칭된다면 $P[1...k]=T[s'+1...s'+k]$를 만족하는 최소 shift $s'>s$는 무엇이며 $s'+k=s+q$는 어디인가?"**

즉, 매칭이 실패할 때 다시 매칭이 성공할 수 있는 s'의 값을 찾는 것이 핵심이다. 위 그림에서 $s'+k=s+q$를 만족하는 $s'$을 보면 5라는 것을 알 수 있다. 따라서, **다시 $T[s+q+1]$과 $P[k+1]$부터 비교하면 되는 것이다.** 이 때, $s'$을 만들기 위한 $s$ 부터의 shift 값을 미리 계산할 수 있는데 그 때 사용하는 것이 바로 prefix와 suffix이다.



## Prefix와 Suffix

패턴 P에 대해 길이 1부터 m까지 각 부분 문자열에서 반복되는 문자열의 길이가 몇인지를 미리 계산함으로써 $s'$의 값을 알아낼 수 있다. 위에서 본 패턴 ababaca에 대해서 계산해보도록 하자. 보통 반복되는 문자열의 길이는 $\pi$로 표시한다.

* **a** : 문자가 1개라 반복될 수 없기 때문에 $\pi[1]=0$이다.
* **ab** : prefix와 suffix가 같지 않기 때문에 $\pi[2]=0$이다.
* **aba** : prefix a와 suffix a가 같기 때문에 $\pi[3]=1$이다.
* **abab** : prefix ab와 suffix ab가 같기 때문에 $\pi[4]=2$이다.
* **ababa** : prefix aba와 suffix aba가 같기 때문에 $\pi[5]=3$이다.
* **ababac** : prefix와 suffix가 같지 않기 때문에 $\pi[6]=0$이다.
* **ababaca** : prefix a와 suffix a가 같기 때문에 $\pi[7]=1$이다.

![default](https://user-images.githubusercontent.com/35518072/40884614-f8938d2a-6751-11e8-9c9c-c4d08fbdea0a.JPG)

그림 (a)를 보면서 이해하면 더 쉽게 이해할 수 있고 그림 (b)를 보면 일부 $\pi$값을 어떤 식으로 구하는지 알 수 있다. 이 값들이 어떻게 적용되는지 살펴보도록 하자. 맨 위의 그림에서 패턴의 문자 5개가 매칭됬고 6번째에서 실패했다. 5번째에서 매칭됬을 때 $\pi[5]=3$이므로, 반복되는 부분문자열의 길이가 3인것을 알 수 있다. **이 말은 매칭되는 부분문자열의 3번째부터 다시 매칭이 된다는 것을 의미한다.**

따라서, $k=3$이라는 것을 알 수 있고 shift의 값은 매칭된 5개에서 다시 매칭이 되는 3개를 뺀 2라는 것을 알 수 있으므로 $s'+k=s+q=8$ 이라는 결론이 나온다. 그 후, shift 2만큼해서 다시 $T[s+q+1]$인 텍스트의 인덱스 9와 $P[k+1]$인 패턴의 인덱스 4부터 계속해서 비교하면 패턴 $P$가 텍스트 $T$에 존재는 여부와 존재한다면 그 위치 또한 파악할 수 있게 된다.

좀 헷갈리니까 더 나아가서 맨 위의 그림에서 (b) 이후의 경우를 보도록 하자. (b)에서 패턴과 텍스트의 부분 문자열인 aba가 매칭된 것을 알 수 있고 바로 그 이후에서 매칭이 실패된다.  이전까지 매칭된 부분 문자열에 대해서 $\pi[3]=1$이므로 shift는 2이며 $s'+k=5+3=8$ 이다. 결국, 텍스트의 인덱스 9와 패턴의 인덱스 2부터 다시 비교하게 된다. 



## 코드

[BOJ 1786번 찾기](https://www.acmicpc.net/problem/1786) 문제를 KMP 알고리즘을 적용해서 풀면 간단하게 풀린다. 코드는 책의 수도코드를 참고해서 그대로 짰다. 2개의 함수가 존재하니 차례대로 살펴보자.

```c++
void COMPUTE_PREFIX_FUNCTION()
{
	int m = P.length() - 1;
	int k = 0;

	for (int q = 2; q <= m; q++) {
		while (k > 0 && P[k + 1] != P[q]) k = pi[k];
		if (P[k + 1] == P[q]) k++;
		pi[q] = k;
	}
}
```

먼저 봐야 할 것은 `COMPUTE_PREFIX_FUNCTION()`으로 이름 그대로 prefix를 계산, 반복되는 부분 문자열이 각 길이에 따라 몇개인지 체크하는 함수이다. 위에서 $\pi$의 값을 계산하는 것이다. vector를 사용했으며 모든 인덱스는 1부터 시작한다. 

코드를 보면 m은 패턴의 길이이며 k와 q를 통해서 패턴 안의 prefix를 찾아낸다. k는 0부터 시작하고 q는 2부터 시작하는데, 3개의 경우로 나뉜다.

* `while (k > 0 && P[k + 1] != P[q]) k = pi[k];` : k>0이라는 말은 하나라도 같은 문자가 존재할 때라는 것이고 인덱스 k+1의 문자와 인덱스 q의 문자가 다를 경우엔 이전까지 일치하는 문자열 중에서 반복되는 인덱스로 다시 k의 값을 초기화시킨다. 이런 이유로 k와 q를 비교하지 않고 k+1과 q를 비교하는 것이다. (이거 쓰면서 알았다.)
* `if(P[k+1] == P[q]) k++;` : 인덱스 k+1의 문자와 인덱스 q의 문자가 같다면 k를 증가시킨다.
* `pi[q] = k;` : 인덱스 q까지 왔을 때, 반복되는 부분 문자열의 인덱스는 k이다. 이렇게 해주는 이유는 이전 과정에서 k에 대해 전부 계산한 것을 통해 q의 길이에 따라 $\pi$ 값을 계산해주어야 하기 때문이다.

```c++
void KMP_MATCHER()
{
	int n = T.length() - 1;
	int m = P.length() - 1;
	COMPUTE_PREFIX_FUNCTION();
	int q = 0;
	for (int i = 1; i <= n; i++) {
		while (q > 0 && P[q + 1] != T[i]) q = pi[q];
		if (P[q + 1] == T[i]) q++;
		if (q == m) {
			kmp.push_back(i - m + 1);
			q = pi[q];
		}
	}
}
```

그 다음은 실제 KMP 알고리즘이 적용된 코드이다. n,m은 텍스트와 패턴의 길이이며 `COMPUTE_PREFIX_FUNCTION()`함수를 불러서 위의 과정들을 진행하고 텍스트의 길이 만큼 반복하는데, prefix를 찾는 알고리즘과 거의 똑같은 것을 알 수 있다. 

* `while (q > 0 && P[q + 1] != T[i]) q = pi[q];` : prefix 때와 마찬가지로 인덱스 q와 i를 기준으로 텍스트와 패턴을 비교해 가면서 달라질 경우 반복되는 부분 문자열의 시작 인덱스로 q를 옮긴다.

* `if (P[q + 1] == T[i]) q++;` : 위와 같다.

* ```c++
  if (q == m) {
  	kmp.push_back(i - m + 1);
  	q = pi[q];
  }
  ```

q가 m이랑 같다는 것은 패턴의 모든 문자가 텍스트의 부분 문자열과 일치했다는 것, 즉 패턴이 발견되었다는 것이므로 vector에 `i-m+1`을 넣는데 이것은 그 발견된 시작 인덱스를 의미한다. 또한 놓치지 말아야 할 것은 패턴이 다시 발견될 수 있으므로 q를 다시 반복되는 부분 문자열의 시작 인덱스로 초기화시켜주어야 한다.



## 시간복잡도

* COMPUTE_PREFIX_FUNCTION()이 $\theta(m)$만큼 걸림.
* KMP_MATCHER()가 $\theta(n)$만큼 걸림.

따라서 총 시간복잡도는 $\theta(n+m)$!! 굉장한 알고리즘이다.



## 자료 및 도움 출처

* Introductions to algorithm, 3rd edition called CLRS
* [라이님의 KMP 알고리즘](https://blog.naver.com/PostView.nhn?blogId=kks227&logNo=220917078260&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F)