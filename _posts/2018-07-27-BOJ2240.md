---
layout: post
category: ps
title: "[BOJ2240]자두나무(못 품)"
---

[문제](https://www.acmicpc.net/problem/2240)

# 어려움

요즘들어 못푸는 문제가 많아져서 좌절감이 몰려오지만 그래도 하나하나 알아간다는 마음으로 어떤 과정을 거쳤고 무엇을 배웠는지 정리하려고 한다.

먼저 처음에 접근한 방법은 D[i]\[j] = i초대에 j번 나무에 있을 때 이제까지 받은 자두의 수라고 정의했지만 생각해보니 움직일 수 있는 한계값이 있었기 때문에 애초에 불가능했다. 계속 어떻게 해야 할지 씨름하다가 질문란을 보았고 한계값을 추가한 3차원 배열을 사용해야 한다는 것을 알았다.

D[i]\[j][k] = j초대에 i번 나무에 있는데 k번 더 움직일 수 있는 경우의 자두 개수라고 정의하면 된다고 해서 이걸 가지고서도 계속해서 풀어보려고 했지만 도저히 풀 수가 없었다. 그래서 다시 해설을 들었고 해설에선 2차원 배열을 사용해서 문제를 풀었다.

<br>

# 점화식 정의

**D[i]\[j] = i초대에서 j번 움직였을 때의 자두개수**라고 정의하면 2가지 경우로 나눌 수 있다.

* **움직이는 경우 : D[i+1]\[j+1]**
* **움직이지 않는 경우 : D[i+1]\[j]**

여기서 i는 시간이기 때문에 계속 증가한다는 것을 주목해야 한다. 움직이는 건 선택할 수 있지만 시간은 계속 흐르는 것이기 때문에 +1씩 해주어야 한다. 하지만 j는 선택에 따라 +1 여부가 달라지므로 2가지로 나누는 것이다.

<br>

# 재귀함수 조건 정의

이제 이걸 이용해서 재귀함수로 문제를 푸는데, 나의 문제점은 재귀함수를 너무 기피한다는 것이다. 실력도 없으면서 어떤 방법이라도 사용해보지 않는 문제점인 것 같다. 반복문이든 재귀함수는 문제가 주어지면 해결하려고 하자! 재귀함수를 이용해서 메모이제이션과 같이 사용하면 아래 2가지 조건을 세울 수 있다.

* **움직인 횟수가 한계값보다 큰 경우  = 문제의 조건 위배**
* **시간이 모두 지난 경우 = 더 이상 받을 자두가 없음**

위 경우엔 결국 받을 자두가 없는 것이므로 0을 리턴해주면 된다. 이 경우가 아니라면 D[i]\[j]가 -1인지 검사해서 값이 들어있는 경우에 리턴한다. -1인지 체크하는 이유는 자두를 0개 받는 경우도 있으므로 처음 초기화 할 때 -1로 전부 초기화하기 때문이다.

<br>

# 움직인 횟수

점화식을 정의할 때 움직인 횟수(=move)를 사용했는데 이걸 통해서 현재 몇번 나무에 있는지 알 수 있다. 처음 자두는 1번 나무에 있기 때문에 move는 0이고 2번으로 가면 1, 다시 1번으로 오면 2로 이어진다. 즉, 짝수는 1번 나무, 홀수는 2번 나무임을 알 수 있으므로 **(move % 2) +1**을 해주면 움직인 횟수에 대한 나무가 나오게 되는 것이다. 따라서 이걸 이용해 식을 세우면 다음과 같다.

```c++
// a는 각 초에 따라 자두가 어떤 나무에서 떨어지는지 저장한 배열, go는 재귀함수
D[i][j] = max(go(i+1, j+1), go(i+1, j)) + (a[sec]==pos ? 1 : 0);
```

**여기서 실수한 부분은 삼항연산자를 쓸 때 괄호를 해주지 않았다는 것이다.** 삼항연산자의 연산자 우선순위는 +보다 낮기 때문에 괄호를 해주지 않으면 `a[sec]`가 먼저 더해지는 일이 발생하기 때문에 원하는 값이 나오지 않게 된다. 조심하자!

<br>

# 함정

해설을 듣고 위 과정까지 하면 끝날 줄 알았는데 문제에서 자두가 움직이는 속도가 1초 미만이라고 했기 때문에 처음에 1번 나무에 있다고 해도 첫 자두가 떨어지기 전에 2번 나무로 이동할 수가 있다. **따라서 시작은 1번, 2번 나무 모두에서 가능하다. (물론 움직인 횟수가 1 증가하겠지만)** 따라서 2가지 경우를 모두 고려해서 최댓값을 구해주어야 한다.

```c++
// 1번나무에서 시작 : 시간 1초, 움직인 횟수 0번
// 2번나무에서 시작 : 시간 1초, 움직인 횟수 1번
printf("%d", max(go(1,0), go(1,1)));
```