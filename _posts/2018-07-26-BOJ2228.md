---
layout: post
category: ps
title: "[BOJ2228]구간 나누기(못 품)"
---

[문제](https://www.acmicpc.net/problem/2228)

처음 접근할 때는 단순하게 D[i]\[j] = i~j까지 중 구간의 최대 총합이라고 생각했는데 도저히 구할 수가 없었고 중간에 k가 있는 경우도 생각해서 i~k와 k+2~j로 생각해 보았지만 구간이 3개 이상인 경우는 어떻게 처리해야 할지 알 수 없었다. 결국 해설을 보았고 다시 한번 점화식에 대해 생각해보는 시간이 되었다.

A를 1차원 배열이라고 했을 때 **D[i]\[j]는 A[1]~A[i]까지 숫자가 있을 때 j개의 구간으로 나눈 경우, 총합의 최대**라고 정의할 수 있다. 이렇게 되면 2가지 경우로 나눌 수 있다.

* i번째 숫자가 구간에 포함되지 않는 경우 : 여전히 구간은 j개 이므로 **D[i-1]\[j]**이다.
* i번재 숫자가 구간에 포함되는 경우 : i번째 숫자가 어떤 구간에 속했다는 말이므로 그 구간이 시작하는 숫자를 k라고 했을 때 k~i 구간에 속하게 되고, 이전 구간은 **D[k-2]\[j-1]**로 나타낼 수 있다. 여기서 k-1이 아니라 **k-2인 이유는 구간이 붙어있을 수 없기 때문이다.**

이제 이걸 통해서 시간복잡도를 구하면 i의 범위는 N이고 j의 범위는 M인데 k가 움직일 수 있는 범위가 N이기 때문에 $O(NM)\times O(N) = O(N^2M)$임을 알 수 있다.

[백준님 코드](https://gist.github.com/Baekjoon/a751e2551ca4577dc1a5)

```c++
// 코드를 이해하기가 어려워 백준님 소스 일부를 그대로 붙여넣어 설명을 붙인 것이다.
int go(int n, int m){
    // 구간이 M개로 모두 쪼개졌기 때문에 계산할 필요 없다.
    if(m == 0) return 0;
    
    // 위에서 걸리지 않았으므로 m>0, 즉 아직 쪼갤 구간이 남았고 현재 쪼개진 구간은
    // M보다 작다는 말이다. 하지만 n<=0이라는 뜻이 배열의 범위를 벗어나기 때문에
    // 사용할 수 없는 값이므로 아주 작은 값을 리턴해서 답을 유지시킨다.
    if(n <= 0) return MIN;
    
    // 메모이제이션이 됬을 경우, 값 그대로 리턴한다 여기서 c는 bool 배열
    if(c[n][m]) return d[n][m];
    c[n][m] = true;
    
    // 재귀함수에서 ans를 공유하기 위해 레퍼런스로 선언한 경우, 알아두자!
    int &ans = d[n][m];
    // 포함되지 않는 경우
    ans = go(n-1,m);
    
    // 포함되는 경우
    int sum = 0;
    for(int k=n; k>=1; k--) {
        sum += a[k];
        int temp = go(k-2, m-1) + sum;
        if(ans < temp) ans = temp;
    }
    return ans;
}
```

여기서 2번째 부분인 `if(n<=0) return MIN` 에서 MIN 대신 0을 리턴하면 구간 M개가 아닌 M개 이하에 대해서 총합의 최대를 구한다는 것이 이해가 안됐다. 그런데 계속 생각해보니까 0을 리턴하게 되면 `ans`가 유지가 되는 것이 아니라 갱신되기 때문에 구간이 M개 이하로 쪼개지는 경우에도 답을 계산하는 것이 된다. 이렇게 이해하면 될 것 같다.