---
layout: post
category: Network
title: "[소켓 프로그래밍]Half Close가 필요한 이유"
---

[윤성우의 TCP/IP 소켓 프로그래밍](http://www.orentec.co.kr/teachlist/TCP_IP_1/teach_sub1.php)을 공부한 내용입니다.

<br>

# TCP에서 기존 종료의 문제점

TCP에선 소켓 통신을 완료하고 끝났을 경우 리눅스에선 `close()`로 윈도우에선 `closesocket()`으로 소켓 통신을 종료했다. 그러나 이렇게 한번에 통신을 끊어버리는 것은 상대방에 대해 고려하지 않고 종료하는 것이므로 문제가 될 수 있다. 예를 들어, A와 B가 통신하는데 A가 마지막으로 B에게 데이터를 보내고 통신을 끊었다고 하자. 하지만 만약에 B가 A에게 보낼 데이터가 남아있다면 A는 이미 통신을 끊었으므로 B의 데이터를 받을 수 없는 상태에 놓이게 된다.

<br>

# 해결 : 스트림을 반만 끊자!

두 호스트간에 소켓이 연결되면 입출력 스트림이 만들어지는데 이 스트림을 통해 데이터를 송수신 할 수 있으므로 위의 기존 방식대로 종료한다는 것은 입출력 스트림을 전부 끊어버린다는 말과 동일하다. 그러나 둘 다 끊지 말고 입력이든 출력이든 하나만 끊어서 문제를 일으키지 않고 연결을 우아하게 종료할 수 있다. 이걸 half close라고 하며 `shutdown`이라는 함수를 사용해서 구현할 수 있다.

```c
#include <sys/socket.h>
int shutdown(int sock, int howto);

// 성공시 0, 실패시 -1 반환
```

두 번째 매개변수로는 아래와 같은 인자들이 전달된다.

* SHUT_RD : 입력 스트림 종료
* SHUT_WR : 출력 스트림 종료
* SHUT_RDWR : 입출력 스트림 종료

<br>

# 구현원리

half close를 구현하는 목적이 상대방이 보낼 데이터가 남아있을 경우인데, 그러기 위해선 상대방으로 하여금 내가 데이터를 다 보냈는지 확인할 수 있어야 한다. **이 때 half close 함수인 `shutdown`을 사용하면 EOF가 전송되는데 이를 이용하면 된다.** 상대방은 EOF를 받고 half close가 된 것을 알게 되며 마지막으로 보낼 데이터를 나에게 전송하게 되는 것이다.

예를 들어, 클라이언트인 A가 서버인 B에게 EX.C 파일을 요청했다고 하면 B은 그 파일을 전부 A에게 보내고 half close를 할 때 EOF를 보내게 된다. A는 EOF를 받고 남은 데이터를 B에게 마지막으로 보내는 방식이다.

코드는 일부만 보도록 하자.

```c
shutdown(clnt_sock, SHUT_WR); // 클라이언트와 연결된 소켓의 출력 스트림 해제
read(clnt_sock, buf, BUF_SIZE); // 입력 스트림은 아직 있으니 남은 데이터 받기
```