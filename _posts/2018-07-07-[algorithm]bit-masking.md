---
layout: post
category: Algorithm
title: "[알고리즘]비트마스킹(Bit Masking)"
---

비트마스킹이란 비트인 0과 1을 이용해 값을 표현하는데 어떤 의미를 숨겨서(마스킹) 표현하는 기법을 말한다. 이해하는 꽤 걸린 알고리즘이고 보통 DP랑 같이 등장하는 문제가 많다. 난이도도 상당한 편이다. 그렇기 때문에 비트마스킹을 어떤 방식으로 쓰는지 정리하고 가려고 한다. 정리는 [라이](https://m.blog.naver.com/PostView.nhn?blogId=kks227&logNo=220787042377&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F)님과 [구구마왕](http://zzonglove.tistory.com/43)님의 블로그를 참고했는데 설명이 정말 자세하다.

# 기본 개념

기본적인 개념은 어떠한 집합을 나타내는 것에서 시작하는데 집합에 4개의 원소가 있다고 하면 각 4개의 원소는 있을 수도 없고 없을 수도 있기 때문에 각 원소의 상태는 2가지로 표현할 수 있다. 따라서 총 원소의 상태 가짓수는 $2^4=16$가지가 된다. 이걸 $0000$, 즉 4비트로 표현하는 것이다. 만약 0번째 원소가 있다면(여기선 0번째부터 시작이라고 했을 때), $0001$이 되고 3번째 원소까지 있다면 $1001$이 되는 것이다.



# 중요 연산

비트 연산에서 중요한 연산은 다음 3가지가 있다.

* **K번째 비트가 0인지 1인지 확인**
* **K번째 비트를 0으로 만든다.** (비활성화)
* **K번째 비트를 1로 만든다.** (활성화)

각각 쉬프트 연산자로 나타낼 수 있는데 직관적이지 않기 때문에 천천히 생각하는 것이 좋다.

## K번째 비트가 0인지 1인지 확인

일단 K번째 비트만 활성된 상태를 만드는데 1을 왼쪽으로 K번 쉬프트하면 1이 그만큼 움직이는 것이기 때문에 K번째 비트만 1이된다. 이 기법을 계속 사용하기 때문에 중요하다. 그러면 (1<<K)로 나타낼 수 있고 K번째 비트가 1인 상태에서 0인지 아닌지 확인하려면 비트 연산자 중에서 & 연산자를 사용하면 된다. 따라서 현재 상태를 저장하는 비트를 NUM이라고 하면 NUM & (1<<K)로 구할 수 있다.

## K번째 비트를 0으로 만들기

​위와 동일하기 (1<<K)를 사용하는데 (1<<K)라는 건 K번째 비트가 1이라는 것이므로 비활성화시키기 위해서 K번째 비트만 0으로 만든다. 그러기 위해선 비트 연산자 ~를 쓰면 된다. 1은 0으로, 0은 1로 바꿔주는 연산자이며 ~(1<<K) 와 같이 쓸 수 있고 현재 상태인 NUM과 & 연산을 해주면 0으로 만들 수 있게 된다. NUM&=~(1<<K)로 구할 수 있다.

## K번째 비트를 1로 만들기

마지막으로 1로 만드는 건 K번째 비트만 1로만든 상태에서 \| 연산을 해주면 된다는 걸 위에서 한 것들을 통해 알 수 있으므로 NUM\|=(1<<K)​로 구할 수 있다.