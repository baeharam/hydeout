---
layout: post
category: ps
title: "[BOJ11048]이동하기"
---

[백준님 강의](https://code.plus/lecture/113)를 듣고 이동하기 문제를 푸는 5가지 방법이 있어서 정리해본다.

<br>

# 1. 현재위치에서 이전위치 생각하기

올 수 있는 방향이 3방향, 왼쪽, 위쪽, 대각선이기 때문에 그 부분을 신경써주면 된다.

```c++
D[i][j] = max(D[i-1][j], D[i][j-1], D[i-1][j-1]) + A[i][j];
```

<br>

# 2. 현재위치에서 다음위치 생각하기

위와 비슷하지만 이번엔 갈 수 있는 위치를 생각하는 것으로 똑같이 3방향이다. 하지만 max를 3번 써야 하는데 그 이유는 각자 도달 위치가 다르기 때문이다.

```c++
D[i+1][j+1] = max(D[i+1][j+1], D[i][j]+A[i+1][j+1]);
D[i+1][j] = max(D[i+1][j], D[i][j]+A[i+1][j]);
D[i][j+1] = max(D[i][j+1], D[i][j]+A[i][j+1]);
```

<br>

# 3. 대각선 케이스 없애기

대각선으로 갈 수 있는 경우는 3가지이다.

* 오른쪽 -> 아래쪽
* 대각선
* 아래쪽 -> 오른쪽

문제에서 구하는 것이 최댓값이기 때문에 대각선은 처리를 해주지 않아도 된다는 말이다. 문제의 조건에서 모든 값이 양수라고 되어있으므로 대각선은 항상 1번째,3번째 케이스보다 작을 수밖에 없다. 따라서 볼 필요가 없는 것이다. 방법1에서 대각선 부분만 없애면 된다.

```c++
D[i][j] = max(D[i-1][j], D[i][j-1]) + A[i][j];
```

<br>

# 4. Top-Down 재귀

방법 3을 재귀로 바꿔보자. 몇가지 조건들을 정의해주어야 한다.

* i와 j가 1일 경우, (1,1)부터 시작하기 때문에 그냥 리턴해주면 된다. (base case)
* i<1 이거나 j<1인 경우, 불가능한 경우이므로 0을 리턴한다.
* D[i]\[j] >= 0인 경우, 메모이제이션을 해서 값을 저장해놓았을 때 리턴해준다. 주의할 점은 처음에 0으로 초기화하지 말고 -1같은 다른 값으로 초기화해야 한다는 점이다.

이제 대각선 케이스를 없앤 2가지 경우만 고려하자.

```c++
D[i][j] = go(i-1, j) + A[i][j];
int temp = go(i, j-1);
if(D[i][j] < temp) D[i][j] = temp;
return D[i][j];
```

<br>

# 5. 점화식을 바꾸자

이제까지의 점화식은 D[i]\[j]라고 했을 때 (1,1)에서부터 (i,j)까지 도달했을 때 사탕의 최대 개수였다. 그러나 이걸 (i,j)에서 이동을 시작했을 때, 가져올 수 있는 최대 사탕 개수로 정의할 수 있다. (i,j)에서 이동을 시작하면 (i+1, j)와 (i, j+1)로 갈 수 있으니 다시 2개의 부분문제로 나뉘게 된다. 따라서 아래와 같이 식을 쓸 수 있다.

```c++
D[i][j] = max(D[i+1][j], D[i][j+1]) + A[i][j];
```

이 방법의 특이한 점은 이제까지의 방법들과는 답의 위치가 다르다는 점이다. 지금까지의 방법들은 모두 D[N]\[M]이 답이었지만 이번 방법은 점화식이 달라졌기 때문에 D[1]\[1]이 답이 된다. 재귀로 풀 경우 D[N]\[M]까지 쭉 들어갔다가 리턴되면서 마지막에 D[1]\[1]이 리턴되기 때문이다.