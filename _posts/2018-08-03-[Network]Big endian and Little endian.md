---
layout: post
category: Network
title: "[소켓 프로그래밍]빅 엔디안과 리틀 엔디안"
---

[윤성우의 TCP/IP 소켓 프로그래밍](http://www.orentec.co.kr/teachlist/TCP_IP_1/teach_sub1.php)을 공부하며 정리한 내용입니다.

# CPU의 데이터 저장 방식

4바이트 정수 1을 메모리 공간에 저장한다고 해보자. CPU에 따라서 그 방식이 달라질 수 있는데 어떤 CPU는 순서대로 저장하는 반면, 어떤 CPU는 역으로 저장한다. 

```c
00000000 00000000 00000000 00000001 // 순서대로 저장
00000001 00000000 00000000 00000000 // 거꾸로 저장
```

네트워크를 통해 컴퓨터 간에 통신이 일어나고 교환한 데이터를 저장하게 되는데, 위와 같이 그 저장방식이 틀리다면 문제가 발생할 것이다.

<br>

# 바이트 순서와 네트워크 바이트 순서

CPU의 데이터 저장방식은 빅 엔디안(Big Endian)과 리틀 엔디안(Little Endian)으로 나뉜다.

* **빅 엔디안** : 상위(왼쪽) 바이트의 값을 작은 번지수에 저장하는 방식, 즉 순서대로 저장.
* **리틀 엔디안** : 상위(왼쪽) 바이트의 값을 큰 번지수에 저장하는 방식, 즉 역으로 저장.

예를 들어, 빅 엔디안을 사용하는 컴퓨터가 0x1234를 0x12와 0x34로 보낸다고 하면 리틀 엔디안을 사용하는 컴퓨터는 역으로 저장하기 때문에 0x3412로 해석하게 된다. **이렇게 CPU마다 바이트 순서를 해석하는 방식이 다르므로 네트워크를 통해 전송할 때는 통일된 기준으로 전송하자는 것이 네트워크 바이트 순서이다.** 네트워크 바이트 순서는 **빅 엔디안 방식으로 통일**하기로 했고, 따라서 리틀 엔디안을 사용하는 컴퓨터는 전송할 때 빅 엔디안의 정렬방식으로 데이터를 재정렬해야 한다.

<br>

# 바이트 순서 변환

네트워크나 호스트 사이에서 빅 엔디안과 리틀 엔디안에 따라 변환을 시켜야 하는데 그걸 도와주는 함수가 여러개 있다.

```c
unsigned short htons(unsigned short);
unsigned short ntohs(unsigned short);
unsigned long htonl(unsigned long);
unsigned long ntohl(unsigned long);
```

h는 호스트의 바이트 순서를, n은 네트워크의 바이튼 순서를 의미한다. 또한 s는 short, l은 long을 의미한다. 위의 함수들 중 하나를 보면 `ntohs`는 네트워크 바이트 순서를 호스트 바이트 순서로 바꾸는데 그 데이터가 short형인 것이다. 보통 s는 포트 번호의 변환에, l은 ip주소의 변환에 사용된다.

<br>

# C : Alternative Form

위 함수들을 사용해보는 예제를 따라하다가 `printf`의 포맷 중에서 `#`이 나와 기능이 무엇인지 궁금했고 alternative form이라는 것임을 알았다. 말 그대로 출력 포맷에 따라 대체해주는 형태라고 보면 된다. 여기서 사용한 것은 16진수를 출력하는데 `0x`를 직접 써주지 않고 `#`을 써서 자동으로 출력하도록 했다.	 더 자세한 내용은 [스택오버플로우](https://stackoverflow.com/a/18527164)를 참고하도록 하자. 레퍼런스까지 같이 나와있다.

